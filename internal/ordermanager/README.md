# Order Manager

## Overview
The order manager is parted in three files, which handles orders, queues and
calculates cost for taking an order. It keeps track of both the primary and the 
backup queue, and is the only package with accsess to the queues. This means 
that it is interfacing between the `FSM`, the `network manager` and getting 
order from the `hardware manager`.

## Exported functions
* `OrderManager`
    * Main function of order manager, which starts all subrutines associated 
    with this package
    * **Input argument(s):** None
    * **Return argument(s):** None

* `OrderInQueue`
    * Checks if the order is in the primary queue
    * **Input argument(s):** `order`
    * **Return argument(s):** `bool` True if the order is in the queue, false if
    not

* `GetFirstOrderInQueue`
    * Returns the first order in the primary queue
    * **Input argument(s):** None
    * **Return argument(s):** `order` The first order

* `QueueEmpty`
    * Checks if the primary queue is empty
    * **Input argument(s):** None
    * **Return argument(s):** `bool` True if the queue is empty, false if not

## Implementation

The order manager is handling all logic for the local elevator to function. It 
preps order request from the hardware manager for the network manager, so 
network manager only is interfacing with order manager. The package is sliced 
into three files, `order.go`, `queue.go` and `cost.go`, in order to increase
readability.

### order.go
The main file for the package, which handles all new orders (and order requests)
coming either from the network manager or the hardware manager. It is always 
listning for new orders and cost request from the network manager and handles 
them respectivly.

### queue.go
This file is only working with the primary- and backup queue, adding/deleting 
orders from the queues. In addition to also saving the queue in a json file and 
loading the file if the system would crash and need to reboot.

### cost.go
When called upon in `order.go`, it generates a cost for taken a given order at 
the place and state the elevator is in at the moment. The cost is then sent back
to `order.go`.

### Order types

There are two types of orders in the system which differentiate on where they 
originate from. This is done to separate the orders coming from the physical 
buttons with the ones that are broadcasted over UDP. The types are

* **HW order:** A hardware order is an order coming from the buttons on the 
elevator
* **SW order:** A software order is an order broadcasted via UDP

The HW orders come from the hardware manager and are relayed to the order 
manager. This order will form the basis for the cost request generated by the
order manager. Once the order manager has received answers from the cost
request, it will choose the two lowest costs and broadcast the order to those 
elevators. This broadcasted message is a SW order and once an elevator receives
a SW order with its address on the destination address it adds it to the primary
or backup queue, depending on what order it is. *Note that this implies that 
only SW orders received from a broadcast message can be added to any of the two 
order queues.*

### Order flow

The auction based system is therefore so that every elevator connected to the 
network competes for every order, even the elevator that starts the auction.

Once a HW order is received from the HW manager a cost request is generated and
the elevators with the lowest cost are selected. To generalize the system, this
is done for all orders, even inside orders. This means that if the elevator is 
disconnected from the others, it will only receive one cost answer and this will
be from itself. It will then choose itself to take the order. 

The same idea applies to inside orders which cannot be shared with another 
elevator. The cost of an inside order for any elevator other than the one who 
received it on its elevator will simply be the highest cost possible and thus 
the elevator which received it will be chosen.

